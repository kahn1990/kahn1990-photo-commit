-- phpMyAdmin SQL Dump
-- version 4.0.10deb1
-- http://www.phpmyadmin.net
--
-- 主机: localhost
-- 生成日期: 2014-11-03 15:19:15
-- 服务器版本: 5.5.40-0ubuntu0.14.04.1
-- PHP 版本: 5.5.9-1ubuntu4.5

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- 数据库: `kangcool`
--

-- --------------------------------------------------------

--
-- 表的结构 `k_blogs`
--

CREATE TABLE IF NOT EXISTS `k_blogs` (
  `kt_blogs_ids` int(20) NOT NULL AUTO_INCREMENT,
  `kt_blogs_dates` datetime DEFAULT NULL,
  `kt_blogs_contents` text,
  `kt_blogs_titles` varchar(100) DEFAULT NULL,
  `stochastic_figure` text,
  `kt_tags_ids` int(20) DEFAULT NULL,
  `kt_blogs_year` varchar(50) DEFAULT NULL,
  `kt_blogs_yue` varchar(50) DEFAULT NULL,
  `kt_blogs_ri` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`kt_blogs_ids`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=63 ;

--
-- 转存表中的数据 `k_blogs`
--

INSERT INTO `k_blogs` (`kt_blogs_ids`, `kt_blogs_dates`, `kt_blogs_contents`, `kt_blogs_titles`, `stochastic_figure`, `kt_tags_ids`, `kt_blogs_year`, `kt_blogs_yue`, `kt_blogs_ri`) VALUES
(50, '2014-10-21 08:40:36', '<p>１、什么是FOUC？你如何来避免FOUC</p>\n\n<blockquote>\n<p>如果使用import方法对CSS进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC.原因大致为：</p>\n\n<ul>\n	<li>使用import方法导入样式表</li>\n	<li>将样式表放在页面底部</li>\n	<li>有几个样式表，放在html结构的不同位置，其实原理很清楚：当样式表晚于结构性html加载，当加载到此样式表时，页面将停止之前的渲染，此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象</li>\n</ul>\n\n<p>解决方法：使用LINK标签将样式表放在文档HEAD中更多</p>\n</blockquote>\n\n<p>&nbsp;<em>２、对网页标准和标准制定机构重要性&nbsp;</em></p>\n\n<blockquote>\n<p>w3c存在的意义就是让浏览器兼容性问题尽量小，首先是他们对浏览器开发者的约束，然后是对开发者的约束</p>\n</blockquote>\n\n<p>３、减低页面加载时间的方法</p>\n\n<blockquote>\n<ul>\n	<li>\n	<p>减少页面HTTP请求数量</p>\n	</li>\n	<li>\n	<p>使用CDN(Content Delivery Network)网络加速<br />\n	现在国内做CDN加速业务的公司很多，简单讲，就是将你的图片、视频扩散到CDN网络所能到达之处，让用户访问时能就近下载到这些文件，从而达到网络提速的目的，这样做，同时能减轻你自己网站的负载。</p>\n	</li>\n	<li>添加文件过期或缓存头 对于同一用户频繁访问的图片、Js脚本文件等可以在Apache或Nginx设置其缓冲 时间，例如设置24小时过期时间，这样用户在访问过该页面之后再次访问时，同一组图片或JS不会再重复下载，从而减少了HTTP请求，用户访问速度明显有 所提升，同时服务器负载也会下降。下面给出nginx配置中缓存控制的例子：\n	<pre class="linenums" id="prettyprint">\nlocation ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$   \n{   \nexpires 30d;#设置30天过期  \n}  \nlocation ~ .*\\.(js|css)?$   \n{  \nexpires 1h;#设置1小时过期  \n} </pre>\n	</li>\n	<li>\n	<p>服务器开启gzip压缩</p>\n\n	<p>这个大家都比较了解，即将需要传输的内容压缩后传输到客户端再解压，这样在网络上传输的 数据量会大幅减小。通常在服务器上的Apache、Nginx可以直接开启这个设置，也可以从代码角度直接设置传输文件头，增加gzip的设置，也可以从 负载均衡设备直接设置。不过需要留意的是，这个设置会略微增加服务器的负担。</p>\n	</li>\n	<li>\n	<p>css格式定义放置在文件头部</p>\n\n	<p>这项设置对于用户端是慢速网络或网页内容比较庞大的情况比较有利，可以在网页逐步呈现的同时仍会保持格式信息，不影响网页美感。</p>\n	</li>\n	<li>\n	<p>Javascript脚本放在文件末尾</p>\n\n	<p>很多Javascript脚本执行效率低下，或者有的第3方域名脚本出现意外无法载入， 如果将这些脚本放置到页面比较靠前的位置，可能会导致我们自己网站的内容载入速度下降甚至无法正常加载，所以一般将这些脚本放置在网页文件末尾，一定要放 置在前面的脚本要改用所谓的&ldquo;后载入&rdquo;方式加载，在主体网页加载完成后再加载，防止其影响到主体网页的加载速度。</p>\n	</li>\n	<li>\n	<p>避免使用CSS脚本(CSS Expressions)</p>\n\n	<p>有时为了要css的参数动态改变，可能会采用css expression来实现，但这样做得不偿失，会使用户端浏览器负担明显加重，所以不建议这样做，如果需要改变，可以使用Javascript脚本去实现。</p>\n	</li>\n	<li>\n	<p>css、javascript改由外部调用</p>\n\n	<p>如果css、js内容比较庞大，尽量不要写到同1个页面中去，改由外部载入比较妥当，因为浏览器本身会对css、js文件进行缓存。</p>\n	</li>\n	<li>\n	<p>压缩Javascript、CSS代码</p>\n\n	<p>一般js、css文件中存在大量的空格、换行、注释，这些利于阅读，如果能够压缩掉，将会很有利于网络传输。这方面的工具也有很多，一般可以保留开发版本，利用工具生成生产版本，2个文件比较，一般压缩率能达到50%以上，减少的数据量还是比较可观的。</p>\n	</li>\n	<li>\n	<p>避免采用301、302转向</p>\n	</li>\n	<li>\n	<p>养成良好的开发维护习惯，尽量避免脚本重复调用</p>\n	</li>\n	<li>\n	<p>配置ETags</p>\n	</li>\n	<li>\n	<p>Ajax采用缓存调用</p>\n\n	<p>这个的使用可以参照Discuz论坛代码，里面对于大量使用的Ajax调用都采用了缓存 调用方式，一般采用附加特征参数方式实现，注意其中的</p>\n\n	<p>&lt;script src=&rdquo;xxx.js?{VERHASH}&rdquo;，{VERHASH}&nbsp;<br />\n	就是特征参数，这个参数不变化就使用缓存文件，如果发生变化则重新下载新文件或更新信 息。</p>\n	</li>\n	<li>\n	<p>合理使用Flush</p>\n\n	<p>用户端发送浏览请求后，服务器端一般要花销200-500ms去处理这些请求，在此期间，用户端浏览器处于等待状态，如果要减少用户等待时间，可以在适当的位置使用flush，将已经就绪的内容推送到用户端，这在php中很容易实现例如：</p>\n\n	<pre class="linenums" id="prettyprint">\n&lt;!-- css, js --&gt; \n&lt;/head&gt; \n&lt;?php flush();?&gt; \n&lt;body&gt; \n... &lt;!-- content --&gt; </pre>\n	</li>\n	<li>\n	<p>Ajax调用尽量采用GET方法调用</p>\n\n	<p>实际使用XMLHttpRequest时，如果使用POST方法实现，会发生2次HTTP请求，而使用GET方法只会发生1次HTTP请求。如果改用GET方法，HTTP请求减少50%！</p>\n	</li>\n	<li>\n	<p>尽可能减少DCOM元素</p>\n\n	<p>这个很好理解，就是尽可能减少网页中各种&lt;&gt;元素数量，例如&lt;table&gt;的冗余很严重，而我们完全可以用&lt;div&gt;取代之。</p>\n	</li>\n	<li>\n	<p>使用多域名负载网页内的多个文件、图片</p>\n\n	<p>记得有资料说明，IE在网页载入过程中，在同1时刻，对同1域名并行加的HTTP请求数 量最高为2个，如果网页需要加载的文件数量超过2个(通常远远超过..)，要加快网页访问速度，最好将文件分布到多个域名，例如19楼，其js文件采用独 立的域名，据说百度的图片服务器数量在20台以上。</p>\n	</li>\n	<li>\n	<p>缩减iframe的使用，如无必要，尽量不要使用</p>\n\n	<p>iframe通常用于不同域名内容的加载，这同时也可能因iframe内容加载速度影响到主网页加载速度，如果可能，把需要加载的内容抓取到本地直接嵌入。如果实在需要iframe加载，采用后载入方式实现。</p>\n	</li>\n	<li>\n	<p>优化图片文件</p>\n\n	<p>优化图片文件，减小其尺寸，特别是缩略图，一定要按尺寸生成缩略图然后调用，不要在网页中用resize方法实现，虽然这样看到的图片外形笑了，但是其加载的数据量一点也没减少。曾经见过有人在网页中加载的缩略图，其真实尺寸有10M之巨&hellip;</p>\n\n	<p>普通图像、icon也要尽可能压缩后，可以采用web图像保存、减少颜色数等等方法实现。</p>\n	</li>\n	<li>\n	<p>当页面内容庞大到一定程度，可以采用分页的方式展现，或者taobao的那种翻页后载入方式。</p>\n	</li>\n</ul>\n</blockquote>\n\n<p>４、如何对网站的文件和资源进行优化</p>\n\n<blockquote>\n<ul>\n	<li>文件合并</li>\n	<li>文件最小化/文件压缩</li>\n	<li>使用CDN托管</li>\n	<li>缓存的使用</li>\n	<li>其他&nbsp;</li>\n</ul>\n</blockquote>\n\n<p>５、语义化的HTML</p>\n\n<blockquote>\n<ul>\n	<li>什么是HTML语义化<br />\n	&lt;基本上都是围绕着几个主要的标签，像标题（H1~H6）、列表（li）、强调（strong em）等等&gt; 　　根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</li>\n	<li>为什么要语义化<br />\n	为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看； 用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li>\n	<li>写HTML代码时应注意什么<br />\n	尽可能少的使用无语义的标签div和span； 在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 不要使用纯样式标签，如：b、font、u等，改用css设置。 需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。</li>\n</ul>\n</blockquote>\n\n<p>６、渐进增强和优雅降级之间的不同</p>\n\n<blockquote>\n<ul>\n	<li>优雅降级：<br />\n	使用优雅降级方案，Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，绝大多数Web设计师和开发者都通过专门的样式表或针对不同版本的IE的hack实践过优雅降级了； 使用优雅降级技术时，你必须首先完整的实现了网站，其中包括所有的功能和效果。然后再为那些无法支持所有功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。</li>\n	<li>渐进增强：<br />\n	从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能。渐进增强是值得所有开发者采用的做法。渐进增强方案并不假定所有用户都支持javascript，而总是提供一种候补方法，确保用户可以访问（主要的）内容。 使用渐进增强时，无需为了一个已成型的网站在旧式浏览器下正常工作而做逆向工程。首先，只需要为所有的设备和浏览器准备好清晰且语义化的HTML以及完善的内容，然后再以无侵入（unobtrusive）的方式向页面增加无害于基础浏览器的额外样式和功能。当浏览器升级时，它们会自动地呈现出来并发挥作用。<br /><br />\n	想让网站在任何环境下看起来都保持一致是不可能的，不管为此付出多少努力，结局依旧会令你失望。与其试图让IE看起来堪比年轻它十岁的浏览器，不如努力改善网站的可访问性，或是进行更多的可用性测试，而不仅仅是让页面看起来&ldquo;更靓一点&rdquo;。 某些CSS3特性在不支持它的浏览器中简直是&ldquo;无法模拟实现&rdquo;的，但若使用渐进增强，就无需为了能让你的网站适合所有人而放弃这些技术。仅仅因为部分人不愿或不能升级浏览器，却让使用新型浏览器的用户无法享受CSS3所提供的伟大技术，这是毫无道理可言的。<br /><br />\n	我们应该先让网站能够正常工作于尽可能旧的浏览器上，然后不断为它在新型浏览器上实现更多的增强和改进。随着时间的推移，当越来越多的人开始升级浏览器而浏览器本身的支持度也不断提升时，就会有越来越多的人体验到这些增强和改进，它持续有效的使网站越来越好，却如需你刻意做什么。只需要一次实现，它就让网站的体验与时俱进。</li>\n</ul>\n</blockquote>\n', ' html总结 ', '', 9, ' 2014 ', ' Aug ', ' 1 '),
(51, '2014-10-21 08:40:36', ' <p>１、&lsquo;$&rsquo; 和 &lsquo;$.fn&rsquo; 的区别</p>\n\n<blockquote>\n<ul>\n	<li>$.fn是指jquery的命名空间，加上fn上的方法及属性，会对jquery实例每一个有效。&nbsp;<br />\n	如扩展$.fn.abc()&nbsp;<br />\n	那么你可以这样子：$(&quot;#div&quot;).abc();&nbsp;<br />\n	通常使用extend方法扩展，详细请看API.&nbsp;</li>\n	<li>$.fx是指jquery的特效。&nbsp;<br />\n	如果使用显示、滑动、淡入淡出、动画等。&nbsp;<br />\n	$.fx.off可以关闭动画，其实是直接显示结果。</li>\n</ul>\n</blockquote>\n\n<p>&nbsp;<em>２、</em>.bing()、.live()和.delegate()的区别</p>\n\n<blockquote>\n<p>&nbsp;</p>\n</blockquote>\n\n<p>３、get()和eq()的区别</p>\n\n<blockquote>\n<ul>\n	<li>\n	<pre>\neq返回的是一个jquery对象</pre>\n	</li>\n	<li>\n	<pre>\nget返回的是一个html&nbsp;对象数组</pre>\n	</li>\n	<li>\n	<p>返回的是jQuery对象，就可以继续调用其他方法，返回的是html数组就不能调用jQuery的其他方法</p>\n	例如：\n\n	<pre class="linenums" id="prettyprint">\n$(&quot;ul&nbsp;li&quot;).get(1).css(&quot;color&quot;,&nbsp;&quot;red&quot;);&nbsp;//这个是错误的\n$(&quot;ul&nbsp;li&quot;).eq(1).css(&quot;color&quot;,&nbsp;&quot;red&quot;);&nbsp;&nbsp;//这个是正确的</pre>\n	</li>\n</ul>\n</blockquote>\n\n<p>４、传递到jQuery方法的四种不同值</p>\n\n<blockquote>\n<ul>\n	<li>选择器（字符串），HTML（字符串），回调函数，HTML元素，对象，数组，元素数组，jQuery对象等</li>\n</ul>\n</blockquote>\n ', ' jquery总结 ', '', 9, ' 2014 ', ' Jul ', ' 27 '),
(52, '2014-10-21 08:40:36', '<p>modern workflows for modern webapps 具体指的是yeo、grunt、bower<br />\n------------------------------------<br />\n首先是grunt：the javascript task runner</p>\n\n<p>package.json：放置于项目的根目录中，内容为项目用到了哪些npm模块，与Gruntfile在同一目录中，并且应该与项目的源代码一起被提交。在上述目录(package.json所在目录)中运行npm install将依据package.json文件中所列出的每个依赖来自动安装适当版本的依赖。</p>\n\n<p>Gruntfile: 此文件被命名为 Gruntfile.js 或 Gruntfile.coffee，用来配置或定义任务（task）并加载Grunt插件，简单说就是grunt的配置文件<br />\n------------------------------------<br />\n下面我们仔细看这个Gruntfile配置文件<br />\ngrunt.initConfig初始化配置文件<br />\npkg: grunt.file.readJSON(&#39;tiny-pubsub.jquery.json&#39;),是pkg加载的tiny-pubsub.jquery.json是项目介绍信息的存储文件<br />\nbanner: 在项目生成的文件上面加上pkg内的文件注释<br />\nclean删除目录<br />\nconcat是把我们的js文件做一个合并（在项目中把分开写的js文件合并为一个js文件）<br />\nuglify是js的node版本的压缩工具<br />\nqunit做 qunit测试<br />\njshint检测代码的书写、格式是否规范<br />\nwatch监听需要watch的文件，</p>\n\n<p>&nbsp;&nbsp; &nbsp;grunt.loadNpmTasks(&#39;grunt-contrib-clean&#39;);<br />\n&nbsp;&nbsp; &nbsp;grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;);<br />\n&nbsp;&nbsp; &nbsp;grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);<br />\n&nbsp;&nbsp; &nbsp;grunt.loadNpmTasks(&#39;grunt-contrib-qunit&#39;);<br />\n&nbsp;&nbsp; &nbsp;grunt.loadNpmTasks(&#39;grunt-contrib-jshint&#39;);<br />\n&nbsp;&nbsp; &nbsp;grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);<br />\n是加载插件模块<br />\ngrunt.registerTask(&#39;default&#39;, [&#39;jshint&#39;, &#39;qunit&#39;, &#39;clean&#39;, &#39;concat&#39;, &#39;uglify&#39;]);<br />\n是注册任务名称，名称后面括号内是任务执行时以来的插件模块<br />\n---------------------------<br />\nnpm init&nbsp;<br />\nnpm init命令会创建一个基本的package.json文件<br />\n在一个新建的项目中命令行执行npm init 会提示项目名称、版本号、描述、入口点、测试命令等，然后会自动帮你生成package.json文件<br />\n------------------------------------<br />\noptions<br />\ngruntfile.js配置文件，concat任务中的options就是任务的配置项，options可以写在concat中，也可以写在concat的dist中<br />\n----------------------------------------<br />\nfiles<br />\n文件匹配提供了两个属性：src和dest，src是原目录，dest目标目录<br />\nfiles的dot和expand属性<br />\nexpand处理动态文件匹配<br />\ncmd属性，举例：当src属性目录为usr/lib时，cmd设置为usr，则src省略usr只需设置为lib<br />\nflatten属性，去掉所有路径，只保留文件名</p>\n', ' grunt简介 ', '', 10, ' 2014 ', ' May ', ' 11 '),
(53, '2014-10-21 08:40:36', ' <p>Grunt和 Grunt 插件是通过 npm 安装并管理的，npm是 Node.js 的包管理器。，同时如果你是用Grunt 0.4.x版本的Grunt必须配合Node.js &gt;= 0.8.0版本使用</p>\n\n<p>安装 CLI</p>\n\n<p>首先需要将Grunt命令行（CLI）安装到全局环境中</p>\n\n<p>执行命令&nbsp;</p>\n\n<p>npm install -g grunt-cli</p>\n\n<p>（安装了grunt-cli并不等于已经安装了 Grunt ，Grunt CLI的任务很简单：调用与Gruntfile在同一目录中 Grunt。这样带来的好处是，允许你在同一个系统上同时安装多个版本的 Grunt，可以让多个版本的 Grunt 同时安装在同一台机器上。</p>\n\n<p>CLI 是如何工作的</p>\n\n<p>每次运行grunt 时，他就利用node提供的require()系统查找本地安装的 Grunt，正是由于这一机制，你可以在项目的任意子目录中运行grunt，如果找到一份本地安装的 Grunt，CLI就将其加载，并传递Gruntfile中的配置信息，然后执行你所指定的任务。</p>\n\n<p>拿一份现有的 Grunt 项目练手</p>\n\n<p>假定Grunt CLI已经正确安装，并且已经有一份配置好package.json 和 Gruntfile 文件的项目了，接下来就很容易拿Grunt练手了：</p>\n\n<p>将命令行的当前目录转到项目的根目录下。</p>\n\n<p>执行npm install命令安装项目依赖的库。</p>\n\n<p>执行 grunt 命令。</p>\n\n<p>OK，就是这么简单。还可以通过grunt --help 命令列出所有已安装的Grunt任务（task），但是一般更建议去查看项目的文档以获取帮助信息。</p>\n\n<p>grunt简单示例：jquery-tiny-pubsub project（https://github.com/cowboy/jquery-tiny-pubsub）</p>\n ', ' grunt安装 ', '', 10, ' 2014 ', ' May ', ' 12 '),
(54, '2014-10-21 08:40:36', '<p>concat，是把我们的js文件做一个合并（在项目中把分开写的js文件合并为一个js文件）<br />\nuglify，是js的node版本的压缩工具<br />\nqunit，做 qunit测试<br />\njshint，检测代码的书写、格式是否规范<br />\nwatch，监听需要watch的文件，<br />\n-------------------<br />\n安装Grunt 和 grunt插件</p>\n\n<p>向已经存在的package.json 文件中添加Grunt和grunt插件的最简单方式是通过npm install &lt;module&gt; --save-dev命令。此命令不光安装了&lt;module&gt;，还会自动将其添加到devDependencies 配置段中，遵循tilde version range格式。</p>\n\n<p>例如，下面这条命令将安装Grunt最新版本到项目目录中，并将其添加到devDependencies内：</p>\n\n<p>npm install grunt --save-dev<br />\n同样，grunt插件和其它node模块都可以按相同的方式安装。安装完成后一定要记得将被修改的package.json文件提交到源码管理器中。</p>\n\n<p>Gruntfile<br />\nGruntfile.js 或 Gruntfile.coffee 文件是有效的 JavaScript 或 CoffeeScript 文件，应当放在你的项目根目录中，和package.json文件在同一目录层级，并和项目源码一起加入源码管理器。</p>\n\n<p>Gruntfile由以下几部分构成：</p>\n\n<p>&quot;wrapper&quot; 函数<br />\n项目与任务配置<br />\n加载grunt插件和任务<br />\n自定义任务<br />\nGruntfile文件案例</p>\n\n<p>在下面列出的这个 Gruntfile 中，package.json文件中的项目元数据（metadata）被导入到 Grunt 配置中， grunt-contrib-uglify 插件中的uglify 任务（task）被配置为压缩（minify）源码文件并依据上述元数据动态生成一个文件头注释。当在命令行中执行 grunt 命令时，uglify 任务将被默认执行。</p>\n\n<pre class="linenums" id="prettyprint">\nmodule.exports = function(grunt) {\n\n  // Project configuration.\n  grunt.initConfig({\n    pkg: grunt.file.readJSON(&#39;package.json&#39;),\n    uglify: {\n      options: {\n        banner: &#39;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n&#39;\n      },\n      build: {\n        src: &#39;src/&lt;%= pkg.name %&gt;.js&#39;,\n        dest: &#39;build/&lt;%= pkg.name %&gt;.min.js&#39;\n      }\n    }\n  });\n\n  // 加载包含 &quot;uglify&quot; 任务的插件。\n  grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);\n\n  // 默认被执行的任务列表。\n  grunt.registerTask(&#39;default&#39;, [&#39;uglify&#39;]);\n\n};</pre>\n\n<p>前面已经向你展示了整个 Gruntfile，接下来将详细解释其中的每一部分。</p>\n\n<p>&quot;wrapper&quot; 函数</p>\n\n<p>每一份 Gruntfile （和grunt插件）都遵循同样的格式，你所书写的Grunt代码必须放在此函数内：</p>\n<pre class="linenums" id="prettyprint">\n<p>module.exports = function(grunt) {\n&nbsp; // Do grunt-related things in here\n};</pre>\n项目和任务配置</p>\n\n<p>大部分的Grunt任务都依赖某些配置数据，这些数据被定义在一个object内，并传递给grunt.initConfig 方法。</p>\n\n<p>在下面的案例中，grunt.file.readJSON(&#39;package.json&#39;) 将存储在package.json文件中的JSON元数据引入到grunt config中。 由于&lt;% %&gt;模板字符串可以引用任意的配置属性，因此可以通过这种方式来指定诸如文件路径和文件列表类型的配置数据，从而减少一些重复的工作。</p>\n\n<p>你可以在这个配置对象中(传递给initConfig()方法的对象)存储任意的数据，只要它不与你任务配置所需的属性冲突，否则会被忽略。此外，由于这本身就是JavaScript，你不仅限于使用JSON；你可以在这里使用任意的有效的JS代码。如果有必要，你甚至可以以编程的方式生成配置。</p>\n\n<p>与大多数task一样，grunt-contrib-uglify 插件中的uglify 任务要求它的配置被指定在一个同名属性中。在这里有一个例子, 我们指定了一个banner选项(用于在文件顶部生成一个注释)，紧接着是一个单一的名为build的uglify目标，用于将一个js文件压缩为一个目标文件。</p>\n<pre class="linenums" id="prettyprint">\n<p>// Project configuration.\ngrunt.initConfig({\n&nbsp; pkg: grunt.file.readJSON(&#39;package.json&#39;),\n&nbsp; uglify: {\n&nbsp; &nbsp; options: {\n&nbsp; &nbsp; &nbsp; banner: &#39;/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n&#39;\n&nbsp; &nbsp; },\n&nbsp; &nbsp; build: {\n&nbsp; &nbsp; &nbsp; src: &#39;src/&lt;%= pkg.name %&gt;.js&#39;,\n&nbsp; &nbsp; &nbsp; dest: &#39;build/&lt;%= pkg.name %&gt;.min.js&#39;\n&nbsp; &nbsp; }\n&nbsp; }\n});\n</pre>\n加载 Grunt 插件和任务</p>\n\n<p>像 concatenation、[minification]、grunt-contrib-uglify 和 linting这些常用的任务（task）都已经以grunt插件的形式被开发出来了。只要在 package.json 文件中被列为dependency（依赖）的包，并通过npm install安装之后，都可以在Gruntfile中以简单命令的形式使用：</p>\n\n<p>// 加载能够提供&quot;uglify&quot;任务的插件。<br />\ngrunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);<br />\n注意： grunt --help 命令将列出所有可用的任务。</p>\n\n<p>自定义任务</p>\n\n<p>通过定义 default 任务，可以让Grunt默认执行一个或多个任务。在下面的这个案例中，执行 grunt 命令时如果不指定一个任务的话，将会执行uglify任务。这和执行grunt uglify 或者 grunt default的效果一样。default任务列表数组中可以指定任意数目的任务（可以带参数）。</p>\n\n<p>// Default task(s).<br />\ngrunt.registerTask(&#39;default&#39;, [&#39;uglify&#39;]);<br />\n如果Grunt插件中的任务（task）不能满足你的项目需求，你还可以在Gruntfile中自定义任务（task）。例如，在下面的 Gruntfile 中自定义了一个default 任务，并且他甚至不依赖任务配置：</p>\n\n<pre class="linenums" id="prettyprint">\nmodule.exports = function(grunt) {\n\n  // A very basic default task.\n  grunt.registerTask(&#39;default&#39;, &#39;Log some stuff.&#39;, function() {\n    grunt.log.write(&#39;Logging some stuff...&#39;).ok();\n  });\n\n};</pre>\n\n<p>特定于项目的任务不必在 Gruntfile 中定义。他们可以定义在外部.js 文件中，并通过grunt.loadTasks 方法加载。</p>\n', ' 五个基础的task ', '', 10, ' 2014 ', ' May ', ' 13 '),
(55, '2014-10-21 08:40:36', ' <p>contrib-connect，本地产生一个service，可以实时看到代码产生的效果<br />\ncontrib-htmlmin，html压缩<br />\ncontrib-requirejs<br />\nmocha，测试框架<br />\nautoprefixer，<br />\nrev，生成静态的md5文件名<br />\nusemin，<br />\ncontrib-compass，用来处理css文件<br />\ncontrib-imagemin<br />\nsvgmiin<br />\nconcurrent</p>\n ', ' 进阶task ', '', 10, ' 2014 ', ' May ', ' 14 '),
(56, '2014-10-21 08:40:36', '<p>首先在官网(http://nodejs.org/)下载Nodejs： node-&lt;版本号&gt;.tar.gz<br />\n以我的为例：node-v0.10.29.tar.gz</p>\n\n<p>安装nodejs所要依赖的包<br />\nsudo apt-get install build-essential &nbsp; &nbsp; //gcc<br />\nsudo apt-get install libssl-dev &nbsp; &nbsp;//ssl</p>\n\n<p>我们可以先在usr/local下创建一个文件夹<br />\ncd /usr/local<br />\nmkdir node<br />\n然后把node-v0.10.29.tar.gz复制到usr/local目录下<br />\nmv node-v0.10.29.tar.gz /usr/local<br />\n执行解压命令<br />\ntar zxvf node-v0.10.29.tar.gz<br />\n进入解压目录node-v0.10.29<br />\ncd node-v0.10.29<br />\n执行安装命令<br />\n./configure --prefix=/usr/local/node &nbsp;制定编译路径<br />\nmake<br />\nsudo make install<br />\n三种方法配置环境变量，注意 root 权限和普通用户权限<br />\necho &lsquo;export PATH=/usr/local/node/bin:$PATH&rsquo; &gt;&gt; ~/.profile 设置环境变量 &nbsp;<br />\necho &lsquo;export NODE_PATH=/usr/local/node:/usr/local/node/lib/node_modules&rsquo; &gt;&gt; ~/.profile &nbsp; 设置NODE_PATH &nbsp;<br />\nsource ~/.profile</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416277522.png" style="height:481px; width:856px" /><br />\n或者通过执行sudo gedit /etc/environment 将 bin 加入环境变量，然后执行 source /etc/environment 使它立即生效</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/14141627819.png" style="height:481px; width:856px" /></p>\n\n<p>或者也可以 sudo gedit ~/.bashrc 在文件末尾加入变量<br />\nexport PATH=/usr/local/node/bin:$PATH<br />\nexport NODE_PATH=/usr/local/node:/usr/local/node/lib/node_modules<br />\n执行 source ~/.bashrc 立即生效</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416278942.png" style="height:481px; width:856px" /><br />\n安装完成后，验证是否安装成功，输入node &ndash;v<br />\n新版本的nodejs自带npm，输入npm &ndash;v</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416280572.png" style="height:481px; width:856px" /><br />\n用npm安装express<br />\nnpm install express -gd （在ubuntu 下要切换root权限安装）</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416281317.png" style="height:481px; width:856px" /></p>\n\n<p>-g代表安装到NODEPATH的lib里面，而-d代表把相依性套件也一起安装。如果沒有-g的话会安装目前所在的目录(会建立一个nodemodules的文件夹)</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416281815.png" style="height:481px; width:856px" /><br />\n验证是否安装成功：<br />\n之前我们通过 npm install express -gd 安装的 express 对它通过 npm -list 再次验证</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416282477.png" style="height:481px; width:856px" /></p>\n\n<p>可以看到已经安装完成的 express@4.6.1&nbsp;<br />\n我们执行 express --version 命令<br />\nexpress --version</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416283149.png" style="height:481px; width:856px" /></p>\n\n<p>显示为程序 &quot;express&quot; 尚未安装，会提示 apt-get install node-express ( ubuntu 源中的 express )<br />\n这是因为 express 默认安装是最新的版本，已经是4.x.x的版本。而最新express4.0+版本中将命令工具分出来了，所以必须要安装express-generator，执行：<br />\nnpm install express-generator -gd</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416282904.png" style="height:481px; width:856px" /></p>\n\n<p>安装 express-generato 再执行 express --version 或者 express -V</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416286917.png" style="height:640px; width:856px" /></p>\n\n<p>从图中我们可以看到 express 命令已经生效，显示版本为 express 4.2.0，（但是我们安装的是 express 4.6.1，为什么显示为 4.2.0 呢，这个我也搞不懂，后来才知道4.2.0是 express-generator 的版本号）<br />\n---------------------------------------------------------------------------------<br />\n或者我们也可以按照官网的步骤<br />\n在自己设定的工程目录下（如我的nodework目录）<br />\ncd /home/kahn/nodework<br />\n输入 npm info express version 查看最新版本号</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416283535.png" style="height:640px; width:856px" /></p>\n\n<p>编写package.json文件<br />\nvim package.json 或者 gedit package.json</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416284178.png" style="height:640px; width:856px" /></p>\n\n<p>输入 npm install 安装项目</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416284851.png" style="height:640px; width:856px" /></p>\n\n<p>输入 npm ls 验证 express 是否安装并显示 express 包及其依赖关系</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416286391.png" style="height:640px; width:856px" /></p>\n\n<p>我在官网(http://nodejs.org/)看到的教程，在当前工程目录下创建app.js文件</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416286112.png" style="height:481px; width:856px" /></p>\n\n<p>输入 node app.js 启动 app.js 在浏览器输入 localhost:3000/hello.txt</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416286229.png" style="height:481px; width:856px" /></p>\n', ' node笔记（一）', '', 11, ' 2014 ', ' May ', ' 14 '),
(57, '2014-10-21 08:40:36', ' <p>​在我的用户目录下建立nodework文件夹方便管理nodejs工程<br />\ncd /home/kahn<br />\nmkdir nodework<br />\n进入nodework<br />\ncd nodework<br />\n新建一个工程把nodespace文件夹作为我们的工程目录<br />\nexpress -e nodespace</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416288625.png" style="height:481px; width:856px" /></p>\n\n<p>我们打开原本空的nodework文件夹就会发现自动生成nodespace文件夹，并且nodespace中生成了许多文件</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416289299.png" style="height:481px; width:856px" /></p>\n\n<p>我们也可以通过桌面文件浏览器查看这些文件</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416288511.png" style="height:481px; width:856px" /></p>\n\n<p>在express 3.x版本中我们使用ejs时不再是 -t ejs，而是 -e．可以通过输入express -h 查看</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416290105.png" style="height:481px; width:856px" /></p>\n\n<p>如果命令行现在已经在nodespace文件夹中 输入 npm install 安装所需模块<br />\n否则通过 cd /home/kahn/nodework/nodespace &amp; npm install 安装所需模块</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/14141629074.png" style="height:481px; width:856px" /></p>\n\n<p>&nbsp;安装完毕之后输入 node app</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416291307.png" style="height:481px; width:856px" /></p>\n\n<p>我们打开浏览器输入localhost:3000查看效果</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416290522.png" style="height:481px; width:856px" /></p>\n\n<p>很明显我的安装出现了问题，通过调试进行更改<br />\n首先打开layout.jade文件（需要root权限）</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/14141629124.png" style="height:481px; width:856px" /></p>\n\n<p>layout.jade内容如下</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416292874.png" style="height:481px; width:856px" /></p>\n\n<p>我们把第一行的 !!! 更改为 doctype html&nbsp;</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416292569.png" style="height:481px; width:856px" /></p>\n\n<p>重新刷新浏览器localhost:3000地址</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416292672.png" style="height:481px; width:856px" /></p>\n\n<p>到这里我们已经成功部署了一个express工程项目，并指定了ejs模板引擎。</p>\n \n', ' node笔记（二） ', '', 11, ' 2014 ', ' May ', ' 14 '),
(58, '2014-10-21 08:40:36', '<p>​通过前两篇笔记完成了node.js的服务器部署</p>\n<p>​express是一款很优秀的mvc框架</p>\n<p>​node.js的express工程目录如下</p>\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416294135.png" style="height:481px; width:856px" /></p>\n\n<p>其中<br />\napp.js是启动文件（入口文件）<br />\npackage.json存储工程信息及模块依赖，当在dependencies中添加依赖模块时，运行 npm install ，npm 会自动检查当前目录下的 &nbsp; &nbsp; &nbsp; &nbsp;package.json，并自动安装所有指定的模块<br />\nnode_modules存放package.json中安装的模块，当你在package,json中添加依赖的模块并用 npm install 安装完毕之后，该模块会被放在node_modules文件夹中<br />\npublic存放image css js 等文件<br />\nroutes顾名思义存放路由文件<br />\nviews存放视图文件<br />\n然后首先我们先打开app.js看看其中都写了什么</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416294809.png" style="height:481px; width:856px" /><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416294003.png" style="height:481px; width:856px" /></p>\n\n\n\n代码如下\n-------------------------------------------------------------------------------------------------------------------------\n<pre class="linenums prettyprint" id="prettyprint">\n/**\n * Module dependencies.\n */\n\nvar express = require(&#39;express&#39;)\n  , routes = require(&#39;./routes&#39;);\n\nvar app = module.exports = express.createServer();\n\n// Configuration\n\napp.configure(function(){\n  app.set(&#39;views&#39;, __dirname + &#39;/views&#39;);\n  app.set(&#39;view engine&#39;, &#39;ejs&#39;);\n  app.engine(&#39;.html&#39;,require(&#39;ejs&#39;),_express); #把 ejs 扩展文件名为html\n  app.use(express.bodyParser());\n  app.use(express.methodOverride());\n  app.use(app.router);\n  app.use(express.static(__dirname + &#39;/public&#39;));\n});\n\napp.configure(&#39;development&#39;, function(){\n  app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));\n});\n\napp.configure(&#39;production&#39;, function(){\n  app.use(express.errorHandler());\n});\n\n// Routes\n\napp.get(&#39;/&#39;, routes.index);\n\napp.listen(3000, function(){\n  console.log(&quot;Express server listening on port %d in %s mode&quot;, app.address().port, app.settings.env);\n});\n</pre>\n-------------------------------------------------------------------------------------------------------------------------\n这段代码用中文解释就是\n<pre class="linenums prettyprint" id="prettyprint">\n/**\n * 模块 依赖.\n */\n定义 express 并通过 require() 加载 express 模块\n定义 routes 并通过 require() 加载 routes 文件夹以及routes下的index.js等所有文件\n定义 app 并通过 module.exports 接口创建 express服务</pre>\n....................\n------------------------------------------------------------------------------------------------------------------\n我通过改写  app.set(&#39;view engine&#39;, &#39;jade&#39;); 为  app.set(&#39;view engine&#39;, &#39;ejs&#39;); 让它支持ejs引擎，但是结果nodejs又出现了新问题，如下图\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416294184.png" style="height:481px; width:856px" /></p>\n\n<p>发现views里没有ejs格式的文件</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416294665.png" style="height:481px; width:856px" /></p>\n\n<p>创建index.ejs<br />\n内容设置为<br />\n&lt;p&gt;this is .ejs.&lt;/p&gt;<br />\n同时复制一份layout.jade文件为layout.ejs</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416295978.png" style="height:481px; width:856px" /></p>\n\n<p>打开浏览器仍有错误，提示为没有安装ejs模块</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141416295165.png" style="height:481px; width:856px" /></p>\n\n<p>安装ejs模块<br />\n在nodespace文件夹下输入 npm install ejs<br />\n安装完毕后打开浏览器localhost:3000</p>', ' node笔记（三） ', '', 11, ' 2014 ', ' May ', ' 15 '),
(59, '2014-10-25 08:35:55', ' <p>这几天看杜欢、王群锋翻译的《数据结构与算法javascript描述》，就想着写几篇笔记方便日后浏览。</p>\n\n<p>快速排序主要用到了递归，以每个数组的第一个数字作为基准值进行算法排序，示例代码如下：</p>\n\n<pre class="linenums" id="prettyprint">\n&lt;h1&gt;原始数组：&lt;/h1&gt;&lt;p&gt;var list=[44,75,23,43,55,12,64,77,33];&lt;/p&gt;\n    &lt;script&gt;\n    var list=[44,75,23,43,55,12,64,77,33];\n    function qSort(list){\n        if(list.length==0){\n            return [];\n        }\n        var lesser=[];\n        var greater=[];\n        var pivot=list[0];\n        for (var i=1;i&lt;list.length;i++){\n            if(list[i]&lt;pivot){\n                lesser.push(list[i]);\n                console.log(lesser+&quot;+lesser&quot;);\n            }else{\n                greater.push(list[i]);\n                console.log(greater+&quot;+greater&quot;);\n            }\n        }\n        return qSort(lesser).concat(pivot,qSort(greater));\n    }\n    console.log(qSort(list));\n    &lt;/script&gt;</pre>\n\n<p>在控制台中console.log，打印信息如下：</p>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141419743445.png" style="height:481px; width:856px" /></p>\n\n<p>从图中可以很清晰看到算法首先以44为基准值，分成了[23,43,12,33]和[75,55,64,77]两个数组，</p>\n\n<p>继续以23和75为基准值，分成了[12]、[43,33]和[55,64]、[77]四个数组，</p>\n\n<p>[43,33]和[55,64]又分别已43、55继续拆分，</p>\n\n<p>最后重组得到[12, 23, 33, 43, 44, 55, 64, 75, 77]</p>\n ', ' 快速排序 ', '', 12, ' 2014', ' Jan ', ' 1 '),
(60, '2014-10-25 08:54:02', '<p>自底向上归并首先将数据集合分割成单个数组（每个数组中有且仅有一个元素），</p>\n\n<p>然后通过创建一组左右子数组将它们慢慢合并，</p>\n\n<p>每次合并都保存一部分排序好的数据集合，最终合并成完美的集合，代码如下：</p>\n<pre class="linenums" id="prettyprint">\n&lt;h1&gt;原始数组：&lt;/h1&gt;&lt;p&gt;var list=[44,75,23,43,55,12,64,77,33];&lt;/p&gt;\n    &lt;script&gt;\n    function mergeSort( arr ) {\n        if ( arr.length &lt; 2 ) {\n            return;\n        }\n        var step = 1;\n        var left, right;\n        while ( step &lt; arr.length ) {\n            left = 0;\n            right = step;\n            while ( right + step &lt;= arr.length ) {\n                mergeArrays(arr, left, left+step, right, right+step);\n                console.log(&#39;arr:&#39;+arr+&#39;---/---left:&#39;+left+&#39;---/---left+step:&#39;+left+step+&#39;---/---right:&#39;+right+&#39;---/---right+step:&#39;+right+step);\n                left = right + step;\n                right = left + step;\n                console.log(&#39;循环一次结束&#39;+&#39;::::left:::&#39;+left+&#39;::::right:::&#39;+right+&#39;::::step:::&#39;+step);\n            }\n            if ( right &lt; arr.length) {\n                mergeArrays(arr, left, left+step, right, arr.length);\n                console.log(&#39;if::::::::::&#39;+&#39;arr:&#39;+arr+&#39;---/---left:&#39;+left+&#39;---/---left+step:&#39;+left+step+&#39;---/---right:&#39;+right+&#39;---/---arr.length:&#39;+arr.length);\n            }\n            step *=2;\n            console.log(&#39;step:::::&#39;+step);\n        }\n    }\n    function mergeArrays( arr, startLeft, stopLeft, startRight, stopRight) {\n        var rightArr = new Array(stopRight - startRight +1);\n        var leftArr = new Array(stopLeft - startLeft +1);\n        k = startRight;\n        for (var i = 0; i &lt; ( rightArr.length-1 ); ++i) {\n            rightArr[ i ] = arr[ k ];\n            ++k;\n        }\n        k = startLeft;\n        for (var i = 0;i &lt; ( leftArr.length-1); ++i) {\n            leftArr[ i ] = arr[ k ];\n            ++k;\n        }\n        rightArr[ rightArr.length-1 ] = Infinity;\n        leftArr[ leftArr.length-1 ] = Infinity;\n        var m = 0;\n        var n = 0;\n        for (var k = startLeft; k &lt; stopRight; ++k){\n            if ( leftArr[ m ] &lt;= rightArr[ n ]) {\n                arr[ k ] = leftArr[ m ];\n                m++;\n            }\n            else {\n                arr[ k ] = rightArr[ n ];\n                n++;\n            }\n        }\n    }\n    var list=[44,75,23,43,55,12,64,77,33];\n    console.log(list);\n    mergeSort(list)\n    console.log(list);\n    &lt;/script&gt;</pre>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141429742368.png" style="height:481px; width:856px" /></p>\n', ' 归并排序', '', 12, ' 2014 ', ' Oct ', ' 23 '),
(61, '2014-10-25 08:54:02', '<p>希尔排序是插入排序的升级版本，1959年希尔通过将简单排序中两两比较改为设置步长跳跃式比较而突破了n的平方的时间复杂度,</p>\n\n<p>希尔排序的核心理念是它会首先选择较远的元素进行比较，这种方案可以使距离较远的元素更快的回到合适的位置，</p>\n\n<p>这里我们使用【５，３，１】作为间隔序列。代码如下:</p>\n\n<pre class="linenums" id="prettyprint">\n&lt;h1&gt;原始数组：&lt;/h1&gt;&lt;p&gt;var list=[44,75,23,43,55,12,64,77,33];&lt;/p&gt;\n    &lt;script&gt;\n        var list=[44,75,23,43,55,12,64,77,33];\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;function sellsort(){\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;var gaps=[ 5, 3, 1];\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for ( var g = 0; g &lt; gaps.length; ++g){\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for ( var i = gaps[ g ]; i &lt; list.length; ++i ){\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;var temp = list[ i ];\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for ( var j = i; j &gt;= gaps[ g ] &amp;&amp; list[ j - gaps[ g ]] &gt; temp; j -= gaps[ g ] ){\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;list[ j ] = list[ j - gaps[ g ]];\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;list[ j ] = temp;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;var q=i-gaps[ g ]+1;document.write(&#39;以&#39;+gaps[ g ]+&#39;为间隔序列的第&#39;+q+&#39;次：&#39;+list+&#39;&lt;br/&gt;&#39;);\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}document.write(&#39;&lt;br/&gt;&#39;);\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}console.log(list);\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;};\n        sellsort();\n    &lt;/script&gt;</pre>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141439048768.png" style="height:481px; width:856px" /></p>\n', '希尔排序 ', '', 12, ' 2014 ', ' Apr ', ' 4 '),
(62, '2014-10-27 15:05:52', '<p>堆排序是选择排序的升级，通过不断构建大顶堆或者小顶堆来选择最大或者最小的值放入队列前端进行排序，</p>\n\n<p>堆排序任何情况下的时间复杂度都为O(N*logN)，</p>\n\n<p>可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶，</p>\n\n<p>示例代码如下:</p>\n\n<pre class="linenums" id="prettyprint">\n&lt;h1&gt;原始数组：&lt;/h1&gt;&lt;p&gt;var list=[44,75,23,43,55,12,64,77,33];&lt;/p&gt;\n    &lt;script&gt;\n        var list=[44,75,23,43,55,12,64,77,33];\n        function heapSort(array) {\n                        var temp;\n                        var i;\n                        for (i = Math.floor(array.length / 2); i &gt;= 0; i--) {\n                            heapAdjust(array, i, array.length - 1); //将数组array构建成一个大顶堆\n                        }\n                        for (i = array.length - 1; i &gt;= 0; i--) {\n                            /*把根节点交换出去*/\n                            temp = array[i];\n                            array[i] = array[0];\n                            array[0] = temp;\n                            /*余下的数组继续构建成大顶堆*/\n                            heapAdjust(array, 0, i - 1);\n                            /* 输出结果 */\n                            document.write(&quot;&lt;br /&gt;&lt;br /&gt;第&quot; + (array.length - i).toString() + &quot;遍排序的结果是:&quot;);\n                            for (var n = 0; n &lt; array.length; n++) {\n                                    document.write(array[n] + &quot;,&quot;);\n                            }\n                            /* 输出结果结束 */\n                        }\n                }\n                //要调整的子树\n                //start为数组开始下标\n                //max是数组结束下标\n                function heapAdjust(array, start, max) {\n                        var temp, j;\n                        temp = array[start];//temp是根节点的值\n                        for (j = 2 * start; j &lt; max; j *= 2) {\n                        if (j &lt; max &amp;&amp; array[j] &lt; array[j + 1]) {  //取得较大孩子的下标\n                                ++j;\n                        }\n                        if (temp &gt;= array[j])\n                            break;\n                        array[start] = array[j];\n                        start = j;\n                    }\n                array[start] = temp;\n    }\n    heapSort(list);\n    &lt;/script&gt;</pre>\n\n<p><img alt="" src="http://ccjwg.img42.wal8.com/img42/498790_20141024225537/141439362261.png" style="height:481px; width:856px" /></p>\n', ' 堆排序 ', '', 12, ' 2014 ', ' Aug ', ' 8 ');

-- --------------------------------------------------------
--
-- 表的结构 `k_tags`
--

CREATE TABLE IF NOT EXISTS `k_tags` (
  `kt_tags_ids` int(20) NOT NULL AUTO_INCREMENT,
  `kt_tags_name` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`kt_tags_ids`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=13 ;

--
-- 转存表中的数据 `k_tags`
--

INSERT INTO `k_tags` (`kt_tags_ids`, `kt_tags_name`) VALUES
(9, '前端知识点'),
(10, 'grunt'),
(11, 'node.js'),
(12, '数据结构');

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
